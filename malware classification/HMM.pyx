#HMM.pyx
cdef extern from "stdio.h":
    int printf(const char *format, ...)

# Define the print_arr function in Cython
cdef void print_arr(const float *a, int strictupperbound):
    cdef int i
    printf("{ %.4f", a[0])
    for i in range(1, strictupperbound):
        printf(", %.4f", a[i])
    printf(" }\n")

#wrapper function
def call_print_arr(float[:] a):
    print_arr(&a[0], len(a))

# Define the print_2d_arr function in Cython
cdef void print_2d_arr(const float *a, int n_rows, int n_cols):
    cdef int i
    printf("{\n")
    for i in range(n_rows):
        printf("    ")
        print_arr(a + n_cols * i, n_cols)
    printf("}\n")

# Define a Python-accessible wrapper function
def call_print_2d_arr(float[:, :] a):
    print_2d_arr(&a[0, 0], a.shape[0], a.shape[1])

# Define the copy_first_in_second function in Cython
cdef void copy_first_in_second(const float *first, float *second, int strictupperbound):
    cdef int i
    for i in range(strictupperbound):
        second[i] = first[i]

# Define a Python-accessible wrapper function
def call_copy_first_in_second(first, second):
    if len(first) != len(second):
        raise ValueError("Length of first and second arrays must be the same")
    copy_first_in_second(&first[0], &second[0], len(first))

# Define the copy_col_in_arr function in Cython
cdef void copy_col_in_arr(float *arr, int arr_height, int arr_width, const float *col, int nb_col):
    cdef int i
    for i in range(arr_height):
        arr[i * arr_width + nb_col] = col[i]

# Define a Python-accessible wrapper function
def call_copy_col_in_arr(arr, col, nb_col):
    if len(arr) % len(col) != 0:
        raise ValueError("Length of column does not match the height of the array")
    copy_col_in_arr(&arr[0], len(arr) // len(col), len(col), &col[0], nb_col)

# Define the Sum function in Cython
cdef float Sum(const float *a, int strictupperbound):
    cdef float answer = 0
    cdef int i
    for i in range(strictupperbound):
        answer += a[i]
    return answer

# Define a Python-accessible wrapper function
def call_Sum(arr):
    return Sum(&arr[0], len(arr))

# Define the Add function in Cython
cdef void Add(float *a, float d, int strictupperbound):
    cdef int i
    for i in range(strictupperbound):
        a[i] += d

# Define a Python-accessible wrapper function
def call_Add(arr, d):
    Add(&arr[0], d, len(arr))

# Define the Mult function in Cython
cdef void Mult(float *a, float d, int strictupperbound):
    cdef int i
    for i in range(strictupperbound):
        a[i] *= d

# Define a Python-accessible wrapper function
def call_Mult(arr, d):
    Mult(&arr[0], d, len(arr))



# Define the matMult function in Cython
cdef int matMult(float *a, int num_rows_a, int num_cols_a,
                 float *b, int num_rows_b, int num_cols_b,
                 float *c):
    cdef int i, j, k
    cdef int num_cols_c = num_cols_b
    
    # Check if the dimensions are compatible for matrix multiplication
    if num_cols_a != num_rows_b:
        raise ValueError("Number of columns of 'a' must be equal to number of rows of 'b'")
    
    for i in range(num_rows_a):
        for j in range(num_cols_b):
            for k in range(num_cols_a):
                c[i * num_cols_c + j] += a[i * num_cols_a + k] * b[k * num_cols_b + j]
    return 0

# Define a Python-accessible wrapper function
def call_matMult(a, num_rows_a, num_cols_a, b, num_rows_b, num_cols_b, c):
    matMult(&a[0], num_rows_a, num_cols_a, &b[0], num_rows_b, num_cols_b, &c[0])


# Define the Baum welch function in Cython
cdef float Baum_Welch_norm_step(float[:, :] a, float[:, :] b, float[:] init, int[:] obs):
    cdef int NumberOfHiddenStates = a.shape[0]
    cdef int NumberOfWords = b.shape[0]
    cdef int NumberOfObs = len(obs)
    cdef int NumberOfColsA = a.shape[1]
    cdef int NumberOfColsB = b.shape[1]
    cdef int i, j, k, s

    cdef float alphas[NumberOfHiddenStates, NumberOfObs]
    cdef float betas[NumberOfHiddenStates, NumberOfObs]
    cdef float lambdas[NumberOfHiddenStates, NumberOfHiddenStates, NumberOfObs - 1]
    cdef float gammas[NumberOfHiddenStates, NumberOfObs - 1]
    cdef float cs[NumberOfObs]

    cdef float alpha[NumberOfHiddenStates]
    cdef float beta[NumberOfHiddenStates]
    cdef float contalpha[NumberOfHiddenStates]
    cdef float contbeta[NumberOfHiddenStates]
    cdef float sumgammas[NumberOfHiddenStates]
    cdef float newB[NumberOfWords, NumberOfHiddenStates]
    cdef float newA[NumberOfHiddenStates, NumberOfHiddenStates]
    cdef float new_init[NumberOfHiddenStates]
    cdef float log_lik

    # Compute the alphas
    for i in range(NumberOfHiddenStates):
        alpha[i] = b[obs[0], i] * init[i]
    c = Sum(alpha, NumberOfHiddenStates)
    cs[0] = 1 / c
    Mult(alpha, 1 / c, NumberOfHiddenStates)
    copy_col_in_arr(alphas, NumberOfHiddenStates, NumberOfObs, alpha, 0)

    for i in range(1, NumberOfObs):
        for k in range(NumberOfHiddenStates):
            contalpha[k] = 0
        matMult(a, NumberOfHiddenStates, NumberOfColsA, alpha, NumberOfHiddenStates, 1, contalpha)
        for r in range(NumberOfHiddenStates):
            alpha[r] = contalpha[r] * b[obs[i], r]
        c = Sum(alpha, NumberOfHiddenStates)
        cs[i] = 1 / c
        Mult(alpha, 1 / c, NumberOfHiddenStates)
        copy_col_in_arr(alphas, NumberOfHiddenStates, NumberOfObs, alpha, i)

    # Compute the betas
    for r in range(NumberOfHiddenStates):
        beta[r] = 1.0
    Mult(beta, cs[NumberOfObs - 1], NumberOfHiddenStates)
    copy_col_in_arr(betas, NumberOfHiddenStates, NumberOfObs, beta, NumberOfObs - 1)

    for i in range(1, NumberOfObs - 1):
        for r in range(NumberOfHiddenStates):
            beta[r] *= b[obs[NumberOfObs - i], r]
        for k in range(NumberOfHiddenStates):
            contbeta[k] = 0
        matMult(beta, 1, NumberOfHiddenStates, a, NumberOfHiddenStates, NumberOfHiddenStates, contbeta)
        copy_first_in_second(contbeta, beta, NumberOfHiddenStates)
        Mult(beta, cs[NumberOfObs - i - 1], NumberOfHiddenStates)
        copy_col_in_arr(betas, NumberOfHiddenStates, NumberOfObs, beta, NumberOfObs - i - 1)

    # Compute the lambdas
    for s in range(NumberOfObs - 1):
        for i in range(NumberOfHiddenStates):
            for j in range(NumberOfHiddenStates):
                lambdas[i, j, s] = betas[i, s + 1] * b[obs[s + 1], i] * a[i, j] * alphas[j, s]

    # Compute the gammas
    for s in range(NumberOfHiddenStates):
        for i in range(NumberOfHiddenStates):
            for j in range(NumberOfObs - 1):
                gammas[i, j] += lambdas[s, i, j]

    for r in range(NumberOfHiddenStates):
        sumgammas[r] = 0
    for i in range(NumberOfHiddenStates):
        for j in range(NumberOfObs - 1):
            sumgammas[i] += gammas[i, j]

    for k in range(NumberOfObs - 1):
        for j in range(NumberOfHiddenStates):
            newB[obs[k], j] += gammas[j, k] / sumgammas[j]

    for s in range(NumberOfHiddenStates):
        for i in range(NumberOfHiddenStates):
            for j in range(NumberOfObs - 1):
                newA[s, i] += lambdas[s, i, j] / sumgammas[i]
    for s in range(NumberOfHiddenStates):
        new_init[s] = gammas[s, 0]

    log_lik = 0
    for s in range(NumberOfObs):
        log_lik += -1 * log(cs[s])

    copy_first_in_second(newA, a, NumberOfHiddenStates * NumberOfHiddenStates)
    copy_first_in_second(newB, b, NumberOfHiddenStates * NumberOfWords)
    copy_first_in_second(new_init, init, NumberOfHiddenStates)

    return log_lik

# Define a Python-accessible wrapper function
def call_Baum_Welch_norm_step(a, b, init, obs):
    return Baum_Welch_norm_step(&a[0, 0], &b[0, 0], &init[0], &obs[0])